"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const color_1 = require("@heroku-cli/color");
const cli_ux_1 = require("cli-ux");
const netrc_parser_1 = require("netrc-parser");
const opn = require("opn");
const os_1 = require("os");
const vars_1 = require("./vars");
const debug = require('debug')('heroku-cli-command');
class Login {
    constructor(config, heroku) {
        this.config = config;
        this.heroku = heroku;
        this.loginHost = process.env.HEROKU_LOGIN_HOST || 'https://cli-login.heroku.com';
    }
    async login(opts = {}) {
        if (process.env.HEROKU_API_KEY)
            cli_ux_1.default.error('Cannot log in with HEROKU_API_KEY set');
        await netrc_parser_1.default.load();
        const previousEntry = netrc_parser_1.default.machines['api.heroku.com'];
        let input = opts.method;
        const defaultMethod = (previousEntry && previousEntry.method) || 'interactive';
        if (!input) {
            if (opts.expiresIn) {
                // can't use web with --expires-in
                input = 'interactive';
            }
            else if (this.enableWebLogin()) {
                input = await cli_ux_1.default.prompt(`heroku: Login with [${color_1.default.green('w')}]eb, [${color_1.default.green('i')}]nteractive, or [${color_1.default.green('s')}]so`, { default: defaultMethod });
            }
            else {
                input = defaultMethod || 'interactive';
            }
        }
        let auth;
        switch (input) {
            case 'w':
            case 'web':
                auth = await this.web();
                break;
            case 'i':
            case 'interactive':
                auth = await this.interactive(previousEntry && previousEntry.login, opts.expiresIn);
                break;
            case 's':
            case 'sso':
                auth = await this.sso(previousEntry && previousEntry.org);
                break;
            default:
                return this.login(opts);
        }
        await this.saveToken(auth);
        if (previousEntry)
            await this.logout(previousEntry.password);
    }
    async logout(token = this.heroku.auth) {
        if (!token)
            return debug('no credentials to logout');
        const requests = [];
        // for SSO logins we delete the session since those do not show up in
        // authorizations because they are created a trusted client
        requests.push(this.heroku.delete('/oauth/sessions/~')
            .catch(err => {
            err = err.http;
            if (err.statusCode === 404 && err.body && err.body.id === 'not_found' && err.body.resource === 'session') {
                return;
            }
            if (err.statusCode === 401 && err.body && err.body.id === 'unauthorized') {
                return;
            }
            throw err;
        }));
        // grab all the authorizations so that we can delete the token they are
        // using in the CLI.  we have to do this rather than delete ~ because
        // the ~ is the API Key, not the authorization that is currently requesting
        requests.push(this.heroku.get('/oauth/authorizations')
            .then(async ({ body: authorizations }) => {
            // grab the default authorization because that is the token shown in the
            // dashboard as API Key and they may be using it for something else and we
            // would unwittingly break an integration that they are depending on
            const d = await this.defaultToken();
            if (d === token)
                return;
            return Promise.all(authorizations
                .filter(a => a.access_token && a.access_token.token !== this.heroku.auth)
                .map(a => this.heroku.delete(`/oauth/authorizations/${a.id}`)));
        })
            .catch(err => {
            if (err.statusCode === 401 && err.body && err.body.id === 'unauthorized') {
                return [];
            }
            throw err;
        }));
        await Promise.all(requests);
    }
    async web() {
        const { body: urls } = await this.heroku.post(`${this.loginHost}/auth`);
        // TODO: handle browser
        await opn(`${this.loginHost}${urls.browser_url}`, { wait: false });
        cli_ux_1.default.action.start('heroku: Waiting for login');
        const { body: auth } = await this.heroku.get(`${this.loginHost}${urls.cli_url}`);
        if (auth.error)
            cli_ux_1.default.error(auth.error);
        this.heroku.auth = auth.access_token;
        cli_ux_1.default.action.start('heroku: Logging in');
        const { body: account } = await this.heroku.get('/account');
        cli_ux_1.default.action.stop();
        return {
            login: account.email,
            password: auth.access_token,
            refresh: auth.refresh_token,
            method: 'web',
        };
    }
    async interactive(login, expiresIn) {
        process.stderr.write('heroku: Enter your login credentials\n');
        login = await cli_ux_1.default.prompt('Email', { default: login });
        let password = await cli_ux_1.default.prompt('Password', { type: 'hide' });
        let auth;
        try {
            auth = await this.createOAuthToken(login, password, { expiresIn });
        }
        catch (err) {
            if (!err.body || err.body.id !== 'two_factor')
                throw err;
            let secondFactor = await cli_ux_1.default.prompt('heroku: Two-factor code', { type: 'mask' });
            auth = await this.createOAuthToken(login, password, { expiresIn, secondFactor });
        }
        this.heroku.auth = auth.password;
        auth.method = 'interactive';
        return auth;
    }
    async createOAuthToken(username, password, opts = {}) {
        function basicAuth(username, password) {
            let auth = [username, password].join(':');
            auth = Buffer.from(auth).toString('base64');
            return `Basic ${auth}`;
        }
        let headers = {
            authorization: basicAuth(username, password)
        };
        if (opts.secondFactor)
            headers['Heroku-Two-Factor-Code'] = opts.secondFactor;
        const { body: auth } = await this.heroku.post('/oauth/authorizations', {
            headers,
            body: {
                scope: ['global'],
                description: `Heroku CLI login from ${os_1.hostname()}`,
                expires_in: opts.expiresIn || 60 * 60 * 24 * 365 // 1 year
            }
        });
        return { password: auth.access_token.token, login: auth.user.email };
    }
    async saveToken(entry) {
        const hosts = [vars_1.vars.apiHost, vars_1.vars.httpGitHost];
        hosts.forEach(host => {
            if (!netrc_parser_1.default.machines[host])
                netrc_parser_1.default.machines[host] = {};
            netrc_parser_1.default.machines[host].login = entry.login;
            netrc_parser_1.default.machines[host].password = entry.password;
        });
        netrc_parser_1.default.machines[vars_1.vars.apiHost].refresh = entry.refresh;
        netrc_parser_1.default.machines[vars_1.vars.apiHost].method = entry.method;
        netrc_parser_1.default.machines[vars_1.vars.apiHost].org = entry.org;
        if (netrc_parser_1.default.machines._tokens) {
            netrc_parser_1.default.machines._tokens.forEach((token) => {
                if (hosts.includes(token.host)) {
                    token.internalWhitespace = '\n  ';
                }
            });
        }
        await netrc_parser_1.default.save();
    }
    async defaultToken() {
        try {
            const { body: authorization } = await this.heroku.get('/oauth/authorizations/~');
            return authorization.access_token && authorization.access_token.token;
        }
        catch (err) {
            if (!err.http)
                throw err;
            if (err.http.statusCode === 404 && err.http.body && err.http.body.id === 'not_found' && err.body.resource === 'authorization')
                return;
            if (err.http.statusCode === 401 && err.http.body && err.http.body.id === 'unauthorized')
                return;
            throw err;
        }
    }
    enableWebLogin() {
        if (!process.env.HEROKU_LOGIN_HOST)
            return false;
        if (this.config.name === '@heroku-cli/command')
            return true;
        return this.config.channel !== 'stable';
    }
    async sso(org) {
        let url = process.env.SSO_URL;
        if (!url) {
            org = process.env.HEROKU_ORGANIZATION || org;
            if (org) {
                org = await cli_ux_1.default.prompt('Organization name', { default: org });
            }
            else {
                org = await cli_ux_1.default.prompt('Organization name');
            }
            url = `https://sso.heroku.com/saml/${encodeURIComponent(org)}/init?cli=true`;
        }
        cli_ux_1.default.action.start('Opening browser for login');
        // TODO: handle browser
        await opn(url, { wait: false });
        const password = await cli_ux_1.default.prompt('Access token', { type: 'mask' });
        this.heroku.auth = password;
        const { body: account } = await this.heroku.get('/account');
        return { password, login: account.email, method: 'sso', org };
    }
}
exports.Login = Login;
